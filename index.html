<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jhan Franco Castro, Royber Chuquizuta, Hermes Galoc, Mayra E. Tarrillo, Erik P. Vasquez, Jorge L. Villa.">

<title>Anotación de imagenes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Anotación de imagenes</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jhan Franco Castro, Royber Chuquizuta, Hermes Galoc, Mayra E. Tarrillo, Erik P. Vasquez, Jorge L. Villa. </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>I. Introducción</p>
<p>La anotación de imágenes es un proceso fundamental para la creación de datasets destinados a entrenar modelos de visión por computadora, ya que permite estructurar la información visual para algoritmos de aprendizaje automático (Goodfellow et al., 2016). En el caso de la chirimoya, la anotación facilita la identificación de características como forma, tamaño de hoja y peciolo, lo cual resulta crucial para tareas de clasificación o detección en entornos agrícolas (Kamilaris &amp; Prenafeta-Boldú, 2018). Label Studio es una herramienta de código abierto altamente flexible que permite realizar anotaciones de imágenes, textos, audios y más, utilizada ampliamente en proyectos de machine learning por su versatilidad y personalización (Heartex, 2024). Este informe describe de manera detallada el procedimiento paso a paso para realizar la anotación de imágenes de hojas de chirimoya usando Label Studio.</p>
<ol start="2" type="I">
<li>Objetivo</li>
</ol>
<p>Detallar el proceso completo de anotación de 25 imágenes de hojas de chirimoya en Label Studio teniendo en cuenta el área, peciolo y escala (moneda).</p>
<ol start="3" type="I">
<li>Requisitos Previos</li>
</ol>
<p>3.1 Software y Herramientas</p>
<ul>
<li>Label Studio instalado.</li>
<li>Carpeta con imágenes de hojas chirimoya en formato JPEG o JPG</li>
</ul>
<p>IV.Procedimiento</p>
<p>4.1. Inicio y creación del proyecto</p>
<p>4.1.1. Abrir Label Studio</p>
<p><img src="LABELSTUDIO/imag%201.jpeg" class="img-fluid"></p>
<p>4.2.Crear Proyecto</p>
<ul>
<li>Hacer clic en Create Project.</li>
<li>Asignación del nombre: Chirimoya #2</li>
</ul>
<p><img src="LABELSTUDIO/imag%202.jpeg" class="img-fluid"></p>
<p>4.3. Importación de Imágenes</p>
<p>4.3.1. Cargar Dataset</p>
<ul>
<li>En el panel del proyecto, seleccionar Import.</li>
<li>Subir las imágenes: Arrastrando carpetas completas o subiendo individualmente.</li>
<li>Verificar que las imágenes sean las correctas.</li>
</ul>
<p><img src="LABELSTUDIO/imag%203.jpeg" class="img-fluid"></p>
<p>4.4. Proceso de Anotación</p>
<p>4.4.1. Iniciar la anotación</p>
<ul>
<li>Hacer clic en Label setup y se seleccionar el tipo de anotación.</li>
<li>Elegir polygons (polígonos), para trabajar con áreas irregulares.</li>
</ul>
<p><img src="LABELSTUDIO/imag%204.jpeg" class="img-fluid"></p>
<p>4.4.2.Crear anotaciones en cada imagen</p>
<ul>
<li>Seleccionar la etiqueta (hoja, peciolo y escala (moneda)).</li>
<li>Definir los colores para cada una.</li>
</ul>
<p><img src="LABELSTUDIO/imag%205.jpeg" class="img-fluid"></p>
<ul>
<li>Marcar punto por punto el contorno real de la hoja y el peciolo de la chirimoya</li>
</ul>
<p><img src="LABELSTUDIO/imag%206.jpeg" class="img-fluid"></p>
<ul>
<li>Ajustar los bordes para obtener precisión.</li>
</ul>
<p>4.4.3.Validar y guardar</p>
<ul>
<li>Verificar que la anotación esté correctamente ubicada.</li>
</ul>
<p>4.5. Control de calidad</p>
<p>4.5.1. Revisar anotaciones</p>
<p>Label Studio tiene un modo de revisión:</p>
<ul>
<li><p>Corrige bounding boxes mal colocados</p></li>
<li><p>Asegura consistencia entre anotadores</p></li>
<li><p>Usa zoom para verificar bordes precisos</p></li>
</ul>
<p>4.6. Exportar dataset anotado</p>
<p>4.6.1. Obtener las anotaciones</p>
<p>En el panel del proyecto:</p>
<ul>
<li><p>Hacer clic en Export.</p></li>
<li><p>Seleccionar el formato deseado: COCO JSON (ideal para modelos de detección), Pascal VOC XML, YOLO TXT, CSV o JSON estándar.</p></li>
<li><p>Descarga los archivos anotados.</p></li>
<li><p>También se puede realizar captura de pantalla.</p></li>
</ul>
<p>V. Anotación de las 25 hojas de chirimoya</p>
<ul>
<li>H-001</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2001.jpeg" class="img-fluid"></p>
<ul>
<li>H-002</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2002.jpeg" class="img-fluid"></p>
<ul>
<li>H-003</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2003.jpeg" class="img-fluid"></p>
<ul>
<li>H-004</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2004.jpeg" class="img-fluid"></p>
<ul>
<li>H-005</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2005.jpeg" class="img-fluid"></p>
<ul>
<li>H-006</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2006.jpeg" class="img-fluid"></p>
<ul>
<li>H-007</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2007.jpeg" class="img-fluid"></p>
<ul>
<li>H-008</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2008.jpeg" class="img-fluid"></p>
<ul>
<li>H-009</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2009.jpeg" class="img-fluid"></p>
<ul>
<li>H-010</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2010.jpeg" class="img-fluid"></p>
<ul>
<li>H-011</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2011.jpeg" class="img-fluid"></p>
<ul>
<li>H-012</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2012.jpeg" class="img-fluid"></p>
<ul>
<li>H-013</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2013.jpeg" class="img-fluid"></p>
<ul>
<li>H-014</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2014.jpeg" class="img-fluid"></p>
<ul>
<li>H-015</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2015.jpeg" class="img-fluid"></p>
<ul>
<li>H-016</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2016.jpeg" class="img-fluid"></p>
<ul>
<li>H-017</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2017.jpeg" class="img-fluid"></p>
<ul>
<li>H-018</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2018.jpeg" class="img-fluid"></p>
<ul>
<li>H-019</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2019.jpeg" class="img-fluid"></p>
<ul>
<li>H-020</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2020.jpeg" class="img-fluid"></p>
<ul>
<li>H-021</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2021.jpeg" class="img-fluid"></p>
<ul>
<li>H-022</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2022.jpeg" class="img-fluid"></p>
<ul>
<li>H-023</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2023.jpeg" class="img-fluid"></p>
<ul>
<li>H-024</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2024.jpeg" class="img-fluid"></p>
<ul>
<li>H-025</li>
</ul>
<p><img src="LABELSTUDIO/hoja%2025.jpeg" class="img-fluid"></p>
<ol start="6" type="I">
<li>Conclusión</li>
</ol>
<p>La anotación de imágenes en Label Studio constituye un proceso estructurado y altamente flexible que facilita la generación de datasets de alta calidad para proyectos de visión por computadora. Al aplicar un procedimiento sistemático y bien definido, es posible anotar imágenes de hojas de chirimoya de manera consistente y precisa, garantizando la estandarización de las etiquetas y la fiabilidad de los datos obtenidos. Además, Label Studio permite exportar las anotaciones en diversos formatos compatibles con frameworks ampliamente utilizados, como TensorFlow, PyTorch y YOLO, lo que optimiza la integración del dataset en diferentes etapas del desarrollo de modelos de aprendizaje profund</p>
<ol start="7" type="I">
<li>Referencias bibliográficas</li>
</ol>
<ul>
<li>Goodfellow, I., Bengio, Y., &amp; Courville, A. (2016). Deep Learning. MIT Press.</li>
<li>Heartex. (2024). Label Studio Documentation. https://labelstud.io/ Kamilaris, A., &amp; Prenafeta-Boldú, F. X. (2018). Deep learning in agriculture: A - survey. Computers and Electronics in Agriculture, 147, 70–90.</li>
</ul>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>